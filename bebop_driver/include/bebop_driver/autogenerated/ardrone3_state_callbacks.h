/**
Software License Agreement (BSD)

\file      ardrone3_state_callbacks.h
\authors   Mani Monajjemi <mmonajje@sfu.ca>
\copyright Copyright (c) 2015, Autonomy Lab (Simon Fraser University), All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that
the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list of conditions and the
   following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
   following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of Autonomy Lab nor the names of its contributors may be used to endorse or promote
   products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WAR-
RANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, IN-
DIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * ardrone3_state_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/arsdk-xml/ab28dab91845cd36c4d7002b55f70805deaff3c8/xml/ardrone3.xml
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */

#ifndef BEBOP_AUTONOMY_AUTOGENERATED_ardrone3_STATE_CALLBACKS_H
#define BEBOP_AUTONOMY_AUTOGENERATED_ardrone3_STATE_CALLBACKS_H

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_driver/autogenerated/callbacks_common.h"
#include "bebop_driver/bebop_driver.h"

#include "bebop_msgs/msg/ardrone3_media_record_state_picture_state_changed.hpp"
#include "bebop_msgs/msg/ardrone3_media_record_state_video_state_changed.hpp"
#include "bebop_msgs/msg/ardrone3_media_record_state_picture_state_changed_v2.hpp"
#include "bebop_msgs/msg/ardrone3_media_record_state_video_state_changed_v2.hpp"
#include "bebop_msgs/msg/ardrone3_media_record_state_video_resolution_state.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_flat_trim_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_flying_state_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_alert_state_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_navigate_home_state_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_position_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_speed_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_attitude_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_auto_take_off_mode_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_altitude_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_gps_location_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_landing_state_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_state_air_speed_changed.hpp"
#include "bebop_msgs/msg/ardrone3_piloting_statemove_to_changed.hpp"
#include "bebop_msgs/msg/ardrone3_network_state_wifi_scan_list_changed.hpp"
#include "bebop_msgs/msg/ardrone3_network_state_all_wifi_scan_changed.hpp"
#include "bebop_msgs/msg/ardrone3_network_state_wifi_auth_channel_list_changed.hpp"
#include "bebop_msgs/msg/ardrone3_network_state_all_wifi_auth_channel_changed.hpp"
#include "bebop_msgs/msg/ardrone3_media_streaming_state_video_enable_changed.hpp"
#include "bebop_msgs/msg/ardrone3_media_streaming_state_video_stream_mode_changed.hpp"
#include "bebop_msgs/msg/ardrone3_camera_state_orientation.hpp"
#include "bebop_msgs/msg/ardrone3_camera_statedefault_camera_orientation.hpp"
#include "bebop_msgs/msg/ardrone3_camera_state_orientation_v2.hpp"
#include "bebop_msgs/msg/ardrone3_camera_statedefault_camera_orientation_v2.hpp"
#include "bebop_msgs/msg/ardrone3_camera_state_velocity_range.hpp"
#include "bebop_msgs/msg/ardrone3_antiflickering_stateelectric_frequency_changed.hpp"
#include "bebop_msgs/msg/ardrone3_antiflickering_statemode_changed.hpp"
#include "bebop_msgs/msg/ardrone3_gps_state_number_of_satellite_changed.hpp"
#include "bebop_msgs/msg/ardrone3_gps_state_home_type_availability_changed.hpp"
#include "bebop_msgs/msg/ardrone3_gps_state_home_type_chosen_changed.hpp"
#include "bebop_msgs/msg/ardrone3_pro_state_features.hpp"
#include "bebop_msgs/msg/ardrone3_accessory_state_connected_accessories.hpp"

namespace bebop_driver
{
namespace cb
{


// Picture state.
class Ardrone3MediaRecordStatePictureStateChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChanged>::SharedPtr ros_pub_;

  Ardrone3MediaRecordStatePictureStateChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_mediarecordstate_picturestatechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStatePictureStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3MediaRecordStatePictureStateChanged


// Picture record state.
class Ardrone3MediaRecordStateVideoStateChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChanged>::SharedPtr ros_pub_;

  Ardrone3MediaRecordStateVideoStateChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_mediarecordstate_videostatechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStateVideoStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3MediaRecordStateVideoStateChanged


// Picture state.
class Ardrone3MediaRecordStatePictureStateChangedV2 : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChangedV2::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChangedV2>::SharedPtr ros_pub_;

  Ardrone3MediaRecordStatePictureStateChangedV2(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2)
  {
    std::string parameter_value = this->get_parameter("states/enable_mediarecordstate_picturestatechangedv2").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChangedV2>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChangedV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStatePictureStateChangedV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3MediaRecordStatePictureStateChangedV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3MediaRecordStatePictureStateChangedV2


// Video record state.
class Ardrone3MediaRecordStateVideoStateChangedV2 : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChangedV2::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChangedV2>::SharedPtr ros_pub_;

  Ardrone3MediaRecordStateVideoStateChangedV2(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2)
  {
    std::string parameter_value = this->get_parameter("states/enable_mediarecordstate_videostatechangedv2").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChangedV2>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChangedV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStateVideoStateChangedV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3MediaRecordStateVideoStateChangedV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3MediaRecordStateVideoStateChangedV2


// Video resolution. Informs about streaming and recording video resolutions. Note that this is only an indication about what the resolution should be. To know the real resolution, you should get it from the frame.
class Ardrone3MediaRecordStateVideoResolutionState : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3MediaRecordStateVideoResolutionState::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3MediaRecordStateVideoResolutionState>::SharedPtr ros_pub_;

  Ardrone3MediaRecordStateVideoResolutionState(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE)
  {
    std::string parameter_value = this->get_parameter("states/enable_mediarecordstate_videoresolutionstate").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3MediaRecordStateVideoResolutionState>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3MediaRecordStateVideoResolutionState::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStateVideoResolutionState::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3MediaRecordStateVideoResolutionState());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING, arg);
    if (arg)
    {
      msg_ptr->streaming = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING, arg);
    if (arg)
    {
      msg_ptr->recording = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3MediaRecordStateVideoResolutionState


// Drone acknowledges that flat trim was correctly processed.
class Ardrone3PilotingStateFlatTrimChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateFlatTrimChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateFlatTrimChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateFlatTrimChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLATTRIMCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_flattrimchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateFlatTrimChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateFlatTrimChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateFlatTrimChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateFlatTrimChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateFlatTrimChanged


// Flying state.
class Ardrone3PilotingStateFlyingStateChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateFlyingStateChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateFlyingStateChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateFlyingStateChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_flyingstatechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateFlyingStateChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateFlyingStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateFlyingStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateFlyingStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateFlyingStateChanged


// Alert state.
class Ardrone3PilotingStateAlertStateChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateAlertStateChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateAlertStateChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateAlertStateChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_alertstatechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateAlertStateChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateAlertStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAlertStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateAlertStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateAlertStateChanged


// Return home state. Availability is related to gps fix, magnetometer calibration.
class Ardrone3PilotingStateNavigateHomeStateChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateNavigateHomeStateChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateNavigateHomeStateChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateNavigateHomeStateChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_navigatehomestatechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateNavigateHomeStateChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateNavigateHomeStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateNavigateHomeStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateNavigateHomeStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON, arg);
    if (arg)
    {
      msg_ptr->reason = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateNavigateHomeStateChanged


// Drones position changed.
class Ardrone3PilotingStatePositionChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStatePositionChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStatePositionChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStatePositionChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_positionchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStatePositionChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStatePositionChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStatePositionChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStatePositionChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE, arg);
    if (arg)
    {
      msg_ptr->latitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE, arg);
    if (arg)
    {
      msg_ptr->longitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStatePositionChanged


// Drones speed changed. Expressed in the NED referential (North-East-Down).
class Ardrone3PilotingStateSpeedChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateSpeedChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateSpeedChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateSpeedChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_speedchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateSpeedChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateSpeedChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateSpeedChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateSpeedChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX, arg);
    if (arg)
    {
      msg_ptr->speed_x = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY, arg);
    if (arg)
    {
      msg_ptr->speed_y = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ, arg);
    if (arg)
    {
      msg_ptr->speed_z = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateSpeedChanged


// Drones attitude changed.
class Ardrone3PilotingStateAttitudeChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateAttitudeChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateAttitudeChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateAttitudeChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_attitudechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateAttitudeChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateAttitudeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAttitudeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateAttitudeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL, arg);
    if (arg)
    {
      msg_ptr->roll = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH, arg);
    if (arg)
    {
      msg_ptr->pitch = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW, arg);
    if (arg)
    {
      msg_ptr->yaw = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateAttitudeChanged


// Auto takeoff mode
class Ardrone3PilotingStateAutoTakeOffModeChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateAutoTakeOffModeChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateAutoTakeOffModeChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateAutoTakeOffModeChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_autotakeoffmodechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateAutoTakeOffModeChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateAutoTakeOffModeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAutoTakeOffModeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateAutoTakeOffModeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateAutoTakeOffModeChanged


// Drones altitude changed. The altitude reported is the altitude above the take off point. To get the altitude above sea level, see [PositionChanged](#1-4-4).
class Ardrone3PilotingStateAltitudeChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateAltitudeChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateAltitudeChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateAltitudeChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_altitudechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateAltitudeChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateAltitudeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAltitudeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateAltitudeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateAltitudeChanged


// Drones location changed. This event is meant to replace [PositionChanged](#1-4-4).
class Ardrone3PilotingStateGpsLocationChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateGpsLocationChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateGpsLocationChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateGpsLocationChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_gpslocationchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateGpsLocationChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateGpsLocationChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateGpsLocationChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateGpsLocationChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LATITUDE, arg);
    if (arg)
    {
      msg_ptr->latitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LONGITUDE, arg);
    if (arg)
    {
      msg_ptr->longitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LATITUDE_ACCURACY, arg);
    if (arg)
    {
      msg_ptr->latitude_accuracy = arg->value.I8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LONGITUDE_ACCURACY, arg);
    if (arg)
    {
      msg_ptr->longitude_accuracy = arg->value.I8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_ALTITUDE_ACCURACY, arg);
    if (arg)
    {
      msg_ptr->altitude_accuracy = arg->value.I8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateGpsLocationChanged


// Landing state. Only available for fixed wings (which have two landing modes).
class Ardrone3PilotingStateLandingStateChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateLandingStateChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateLandingStateChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateLandingStateChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_landingstatechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateLandingStateChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateLandingStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateLandingStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateLandingStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateLandingStateChanged


// Drones air speed changed Expressed in the drones referential.
class Ardrone3PilotingStateAirSpeedChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStateAirSpeedChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStateAirSpeedChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStateAirSpeedChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AIRSPEEDCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_airspeedchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStateAirSpeedChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStateAirSpeedChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAirSpeedChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStateAirSpeedChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AIRSPEEDCHANGED_AIRSPEED, arg);
    if (arg)
    {
      msg_ptr->air_speed = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStateAirSpeedChanged


// The drone moves or moved to a given location.
class Ardrone3PilotingStatemoveToChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PilotingStatemoveToChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PilotingStatemoveToChanged>::SharedPtr ros_pub_;

  Ardrone3PilotingStatemoveToChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_pilotingstate_movetochanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PilotingStatemoveToChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PilotingStatemoveToChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStatemoveToChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PilotingStatemoveToChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_LATITUDE, arg);
    if (arg)
    {
      msg_ptr->latitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_LONGITUDE, arg);
    if (arg)
    {
      msg_ptr->longitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ORIENTATION_MODE, arg);
    if (arg)
    {
      msg_ptr->orientation_mode = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_HEADING, arg);
    if (arg)
    {
      msg_ptr->heading = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_STATUS, arg);
    if (arg)
    {
      msg_ptr->status = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PilotingStatemoveToChanged


// Wifi scan results. Please note that the list is not complete until you receive the event [WifiScanEnded](#1-14-1).
class Ardrone3NetworkStateWifiScanListChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3NetworkStateWifiScanListChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3NetworkStateWifiScanListChanged>::SharedPtr ros_pub_;

  Ardrone3NetworkStateWifiScanListChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_networkstate_wifiscanlistchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3NetworkStateWifiScanListChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3NetworkStateWifiScanListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateWifiScanListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3NetworkStateWifiScanListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID, arg);
    if (arg)
    {
      msg_ptr->ssid = arg->value.String;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI, arg);
    if (arg)
    {
      msg_ptr->rssi = arg->value.I16;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND, arg);
    if (arg)
    {
      msg_ptr->band = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL, arg);
    if (arg)
    {
      msg_ptr->channel = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3NetworkStateWifiScanListChanged


// Wifi scan ended. When receiving this event, the list of [WifiScanResults](#1-14-0) is complete.
class Ardrone3NetworkStateAllWifiScanChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3NetworkStateAllWifiScanChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3NetworkStateAllWifiScanChanged>::SharedPtr ros_pub_;

  Ardrone3NetworkStateAllWifiScanChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFISCANCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_networkstate_allwifiscanchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3NetworkStateAllWifiScanChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3NetworkStateAllWifiScanChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateAllWifiScanChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3NetworkStateAllWifiScanChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3NetworkStateAllWifiScanChanged


// Available wifi channels. Please note that the list is not complete until you receive the event [AvailableWifiChannelsCompleted](#1-14-3).
class Ardrone3NetworkStateWifiAuthChannelListChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3NetworkStateWifiAuthChannelListChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3NetworkStateWifiAuthChannelListChanged>::SharedPtr ros_pub_;

  Ardrone3NetworkStateWifiAuthChannelListChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_networkstate_wifiauthchannellistchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3NetworkStateWifiAuthChannelListChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3NetworkStateWifiAuthChannelListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateWifiAuthChannelListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3NetworkStateWifiAuthChannelListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND, arg);
    if (arg)
    {
      msg_ptr->band = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL, arg);
    if (arg)
    {
      msg_ptr->channel = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT, arg);
    if (arg)
    {
      msg_ptr->in_or_out = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3NetworkStateWifiAuthChannelListChanged


// Available wifi channels completed. When receiving this event, the list of [AvailableWifiChannels](#1-14-2) is complete.
class Ardrone3NetworkStateAllWifiAuthChannelChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3NetworkStateAllWifiAuthChannelChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3NetworkStateAllWifiAuthChannelChanged>::SharedPtr ros_pub_;

  Ardrone3NetworkStateAllWifiAuthChannelChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_networkstate_allwifiauthchannelchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3NetworkStateAllWifiAuthChannelChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3NetworkStateAllWifiAuthChannelChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateAllWifiAuthChannelChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3NetworkStateAllWifiAuthChannelChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3NetworkStateAllWifiAuthChannelChanged


// Video stream state.
class Ardrone3MediaStreamingStateVideoEnableChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3MediaStreamingStateVideoEnableChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3MediaStreamingStateVideoEnableChanged>::SharedPtr ros_pub_;

  Ardrone3MediaStreamingStateVideoEnableChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_mediastreamingstate_videoenablechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3MediaStreamingStateVideoEnableChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3MediaStreamingStateVideoEnableChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaStreamingStateVideoEnableChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3MediaStreamingStateVideoEnableChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED, arg);
    if (arg)
    {
      msg_ptr->enabled = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3MediaStreamingStateVideoEnableChanged


// 
class Ardrone3MediaStreamingStateVideoStreamModeChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3MediaStreamingStateVideoStreamModeChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3MediaStreamingStateVideoStreamModeChanged>::SharedPtr ros_pub_;

  Ardrone3MediaStreamingStateVideoStreamModeChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_mediastreamingstate_videostreammodechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3MediaStreamingStateVideoStreamModeChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3MediaStreamingStateVideoStreamModeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaStreamingStateVideoStreamModeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3MediaStreamingStateVideoStreamModeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE, arg);
    if (arg)
    {
      msg_ptr->mode = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3MediaStreamingStateVideoStreamModeChanged


// Camera orientation.
class Ardrone3CameraStateOrientation : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3CameraStateOrientation::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3CameraStateOrientation>::SharedPtr ros_pub_;

  Ardrone3CameraStateOrientation(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION)
  {
    std::string parameter_value = this->get_parameter("states/enable_camerastate_orientation").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3CameraStateOrientation>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3CameraStateOrientation::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3CameraStateOrientation::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3CameraStateOrientation());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT, arg);
    if (arg)
    {
      msg_ptr->tilt = arg->value.I8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN, arg);
    if (arg)
    {
      msg_ptr->pan = arg->value.I8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3CameraStateOrientation


// Orientation of the center of the camera. This is the value to send when you want to center the camera.
class Ardrone3CameraStatedefaultCameraOrientation : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientation::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientation>::SharedPtr ros_pub_;

  Ardrone3CameraStatedefaultCameraOrientation(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION)
  {
    std::string parameter_value = this->get_parameter("states/enable_camerastate_defaultcameraorientation").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientation>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientation::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3CameraStatedefaultCameraOrientation::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientation());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_TILT, arg);
    if (arg)
    {
      msg_ptr->tilt = arg->value.I8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_PAN, arg);
    if (arg)
    {
      msg_ptr->pan = arg->value.I8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3CameraStatedefaultCameraOrientation


// Camera orientation with float arguments.
class Ardrone3CameraStateOrientationV2 : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3CameraStateOrientationV2::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3CameraStateOrientationV2>::SharedPtr ros_pub_;

  Ardrone3CameraStateOrientationV2(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2)
  {
    std::string parameter_value = this->get_parameter("states/enable_camerastate_orientationv2").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3CameraStateOrientationV2>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3CameraStateOrientationV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3CameraStateOrientationV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3CameraStateOrientationV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2_TILT, arg);
    if (arg)
    {
      msg_ptr->tilt = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2_PAN, arg);
    if (arg)
    {
      msg_ptr->pan = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3CameraStateOrientationV2


// Orientation of the center of the camera. This is the value to send when you want to center the camera.
class Ardrone3CameraStatedefaultCameraOrientationV2 : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientationV2::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientationV2>::SharedPtr ros_pub_;

  Ardrone3CameraStatedefaultCameraOrientationV2(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2)
  {
    std::string parameter_value = this->get_parameter("states/enable_camerastate_defaultcameraorientationv2").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientationV2>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientationV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3CameraStatedefaultCameraOrientationV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3CameraStatedefaultCameraOrientationV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2_TILT, arg);
    if (arg)
    {
      msg_ptr->tilt = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2_PAN, arg);
    if (arg)
    {
      msg_ptr->pan = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3CameraStatedefaultCameraOrientationV2


// Camera Orientation velocity limits.
class Ardrone3CameraStateVelocityRange : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3CameraStateVelocityRange::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3CameraStateVelocityRange>::SharedPtr ros_pub_;

  Ardrone3CameraStateVelocityRange(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE)
  {
    std::string parameter_value = this->get_parameter("states/enable_camerastate_velocityrange").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3CameraStateVelocityRange>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3CameraStateVelocityRange::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3CameraStateVelocityRange::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3CameraStateVelocityRange());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE_MAX_TILT, arg);
    if (arg)
    {
      msg_ptr->max_tilt = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE_MAX_PAN, arg);
    if (arg)
    {
      msg_ptr->max_pan = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3CameraStateVelocityRange


// Electric frequency. This piece of information is used for the antiflickering when the [AntiflickeringMode](#1-30-1) is set to *auto*.
class Ardrone3AntiflickeringStateelectricFrequencyChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3AntiflickeringStateelectricFrequencyChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3AntiflickeringStateelectricFrequencyChanged>::SharedPtr ros_pub_;

  Ardrone3AntiflickeringStateelectricFrequencyChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_antiflickeringstate_electricfrequencychanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3AntiflickeringStateelectricFrequencyChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3AntiflickeringStateelectricFrequencyChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3AntiflickeringStateelectricFrequencyChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3AntiflickeringStateelectricFrequencyChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY, arg);
    if (arg)
    {
      msg_ptr->frequency = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3AntiflickeringStateelectricFrequencyChanged


// Antiflickering mode.
class Ardrone3AntiflickeringStatemodeChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3AntiflickeringStatemodeChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3AntiflickeringStatemodeChanged>::SharedPtr ros_pub_;

  Ardrone3AntiflickeringStatemodeChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_antiflickeringstate_modechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3AntiflickeringStatemodeChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3AntiflickeringStatemodeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3AntiflickeringStatemodeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3AntiflickeringStatemodeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE, arg);
    if (arg)
    {
      msg_ptr->mode = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3AntiflickeringStatemodeChanged


// Number of GPS satellites.
class Ardrone3GPSStateNumberOfSatelliteChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3GPSStateNumberOfSatelliteChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3GPSStateNumberOfSatelliteChanged>::SharedPtr ros_pub_;

  Ardrone3GPSStateNumberOfSatelliteChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_gpsstate_numberofsatellitechanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3GPSStateNumberOfSatelliteChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3GPSStateNumberOfSatelliteChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3GPSStateNumberOfSatelliteChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3GPSStateNumberOfSatelliteChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE, arg);
    if (arg)
    {
      msg_ptr->number_of_satellite = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3GPSStateNumberOfSatelliteChanged


// Home type availability.
class Ardrone3GPSStateHomeTypeAvailabilityChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3GPSStateHomeTypeAvailabilityChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3GPSStateHomeTypeAvailabilityChanged>::SharedPtr ros_pub_;

  Ardrone3GPSStateHomeTypeAvailabilityChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_gpsstate_hometypeavailabilitychanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3GPSStateHomeTypeAvailabilityChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3GPSStateHomeTypeAvailabilityChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3GPSStateHomeTypeAvailabilityChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3GPSStateHomeTypeAvailabilityChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE, arg);
    if (arg)
    {
      msg_ptr->type = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE, arg);
    if (arg)
    {
      msg_ptr->available = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3GPSStateHomeTypeAvailabilityChanged


// Home type. This choice is made by the drone, according to the [PreferredHomeType](#1-24-4) and the [HomeTypeAvailability](#1-31-1). The drone will choose the type matching with the user preference only if this type is available. If not, it will chose a type in this order: FOLLOWEE ; TAKEOFF ; PILOT ; FIRST_FIX
class Ardrone3GPSStateHomeTypeChosenChanged : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3GPSStateHomeTypeChosenChanged::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3GPSStateHomeTypeChosenChanged>::SharedPtr ros_pub_;

  Ardrone3GPSStateHomeTypeChosenChanged(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED)
  {
    std::string parameter_value = this->get_parameter("states/enable_gpsstate_hometypechosenchanged").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3GPSStateHomeTypeChosenChanged>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3GPSStateHomeTypeChosenChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3GPSStateHomeTypeChosenChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3GPSStateHomeTypeChosenChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE, arg);
    if (arg)
    {
      msg_ptr->type = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3GPSStateHomeTypeChosenChanged


// Pro features.
class Ardrone3PROStateFeatures : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3PROStateFeatures::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3PROStateFeatures>::SharedPtr ros_pub_;

  Ardrone3PROStateFeatures(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES)
  {
    std::string parameter_value = this->get_parameter("states/enable_prostate_features").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3PROStateFeatures>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3PROStateFeatures::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PROStateFeatures::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3PROStateFeatures());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES, arg);
    if (arg)
    {
      msg_ptr->features = arg->value.U64;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3PROStateFeatures


// List of all connected accessories. This event presents the list of all connected accessories. To actually use the component, use the component dedicated feature.
class Ardrone3AccessoryStateConnectedAccessories : public AbstractState
{
private:
  bebop_msgs::msg::Ardrone3AccessoryStateConnectedAccessories::Ptr msg_ptr;

public:
  rclcpp::Publisher<bebop_msgs::msg::Ardrone3AccessoryStateConnectedAccessories>::SharedPtr ros_pub_;

  Ardrone3AccessoryStateConnectedAccessories(const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES)
  {
    std::string parameter_value = this->get_parameter("states/enable_accessorystate_connectedaccessories").as_string();

    if (parameter_value == "true" || parameter_value == "1") {
        pub_enabled_ = true;
    } else {
        pub_enabled_ = false;
    }
    
    if (pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = this->create_publisher<bebop_msgs::msg::Ardrone3AccessoryStateConnectedAccessories>(topic, 10);
    } // pub_enabled_ is false
  }

  bebop_msgs::msg::Ardrone3AccessoryStateConnectedAccessories::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3AccessoryStateConnectedAccessories::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::msg::Ardrone3AccessoryStateConnectedAccessories());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ID, arg);
    if (arg)
    {
      msg_ptr->id = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ACCESSORY_TYPE, arg);
    if (arg)
    {
      msg_ptr->accessory_type = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_UID, arg);
    if (arg)
    {
      msg_ptr->uid = arg->value.String;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_SWVERSION, arg);
    if (arg)
    {
      msg_ptr->sw_version = arg->value.String;
    }

    if (pub_enabled_) ros_pub_->publish(*msg_ptr);
  }

};  // Ardrone3AccessoryStateConnectedAccessories


}  // namespace cb
}  // namespace bebop_driver
#endif  // BEBOP_AUTONOMY_AUTOGENERATED_ardrone3_STATE_CALLBACKS_H