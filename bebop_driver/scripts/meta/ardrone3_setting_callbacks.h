/**
Software License Agreement (BSD)

\file      Ardrone3_setting_callbacks.h
\authors   Mani Monajjemi <mmonajje@sfu.ca>
\copyright Copyright (c) 2015, Autonomy Lab (Simon Fraser University), All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that
the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list of conditions and the
   following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
   following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of Autonomy Lab nor the names of its contributors may be used to endorse or promote
   products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WAR-
RANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, IN-
DIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Ardrone3_setting_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/arsdk-xml/ab28dab91845cd36c4d7002b55f70805deaff3c8/xml/ardrone3.xml
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */
#ifndef BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H
#define BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_driver/autogenerated/callbacks_common.h"
#include "bebop_driver/bebop_driver.h"

namespace bebop_driver
{
namespace cb
{

class PilotingSettingsMaxAltitude : public AbstractSetting
{
private:
  double PilotingSettingsMaxAltitudeCurrent_bebop_value_;
  bool PilotingSettingsMaxAltitudeCurrent_bebop_sent_;
  double PilotingSettingsMaxAltitudeCurrent_param_;

public:
  explicit PilotingSettingsMaxAltitude()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED)
      , PilotingSettingsMaxAltitudeCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxAltitudeCurrent != PilotingSettingsMaxAltitudeCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsMaxAltitudeCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxAltitudeCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsMaxAltitude was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsMaxAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxAltitudeCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsMaxAltitude::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxAltitudeCurrent_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsMaxAltitudeCurrent received: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxAltitudeCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsMaxAltitudeCurrent exists in params ...");
      if (!this->get_parameter("PilotingSettingsMaxAltitudeCurrent", PilotingSettingsMaxAltitudeCurrent_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<double>("PilotingSettingsMaxAltitudeCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsMaxAltitude

class PilotingSettingsMaxTilt : public AbstractSetting
{
private:
  double PilotingSettingsMaxTiltCurrent_bebop_value_;
  bool PilotingSettingsMaxTiltCurrent_bebop_sent_;
  double PilotingSettingsMaxTiltCurrent_param_;

public:
  explicit PilotingSettingsMaxTilt()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED)
      , PilotingSettingsMaxTiltCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxTiltCurrent != PilotingSettingsMaxTiltCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsMaxTiltCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxTiltCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsMaxTilt was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsMaxTilt changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxTilt(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxTiltCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsMaxTilt::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxTiltCurrent_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsMaxTiltCurrent received: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxTiltCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsMaxTiltCurrent exists in params ...");
      if (!this->get_parameter("PilotingSettingsMaxTiltCurrent", PilotingSettingsMaxTiltCurrent_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<double>("PilotingSettingsMaxTiltCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsMaxTilt

class PilotingSettingsAbsolutControl : public AbstractSetting
{
private:
  int32_t PilotingSettingsAbsolutControlOn_bebop_value_;
  bool PilotingSettingsAbsolutControlOn_bebop_sent_;
  int32_t PilotingSettingsAbsolutControlOn_param_;

public:
  explicit PilotingSettingsAbsolutControl()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED)
      , PilotingSettingsAbsolutControlOn_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsAbsolutControlOn != PilotingSettingsAbsolutControlOn_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsAbsolutControlOn changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsAbsolutControlOn_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsAbsolutControl was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsAbsolutControl changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsAbsolutControl(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsAbsolutControlOn)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsAbsolutControl::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON, arg);
    if (arg)
    {
      PilotingSettingsAbsolutControlOn_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsAbsolutControlOn received: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsAbsolutControlOn_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsAbsolutControlOn exists in params ...");
      if (!this->get_parameter("PilotingSettingsAbsolutControlOn", PilotingSettingsAbsolutControlOn_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PilotingSettingsAbsolutControlOn", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsAbsolutControl

class PilotingSettingsMaxDistance : public AbstractSetting
{
private:
  double PilotingSettingsMaxDistanceValue_bebop_value_;
  bool PilotingSettingsMaxDistanceValue_bebop_sent_;
  double PilotingSettingsMaxDistanceValue_param_;

public:
  explicit PilotingSettingsMaxDistance()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED)
      , PilotingSettingsMaxDistanceValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxDistanceValue != PilotingSettingsMaxDistanceValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsMaxDistanceValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxDistanceValue_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsMaxDistance was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxDistanceValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsMaxDistance::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsMaxDistanceValue_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsMaxDistanceValue received: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxDistanceValue_bebop_value_ = static_cast<double>(arg->value.Float);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsMaxDistanceValue exists in params ...");
      if (!this->get_parameter("PilotingSettingsMaxDistanceValue", PilotingSettingsMaxDistanceValue_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<double>("PilotingSettingsMaxDistanceValue", static_cast<double>(arg->value.Float));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsMaxDistance

class PilotingSettingsNoFlyOverMaxDistance : public AbstractSetting
{
private:
  int32_t PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_;
  bool PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_;
  int32_t PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_param_;

public:
  explicit PilotingSettingsNoFlyOverMaxDistance()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED)
      , PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover != PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsNoFlyOverMaxDistance was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsNoFlyOverMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsNoFlyOverMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsNoFlyOverMaxDistance::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER, arg);
    if (arg)
    {
      PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover received: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover exists in params ...");
      if (!this->get_parameter("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover", PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsNoFlyOverMaxDistance

class PilotingSettingsBankedTurn : public AbstractSetting
{
private:
  int32_t PilotingSettingsBankedTurnValue_bebop_value_;
  bool PilotingSettingsBankedTurnValue_bebop_sent_;
  int32_t PilotingSettingsBankedTurnValue_param_;

public:
  explicit PilotingSettingsBankedTurn()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED)
      , PilotingSettingsBankedTurnValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsBankedTurnValue != PilotingSettingsBankedTurnValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsBankedTurnValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsBankedTurnValue_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsBankedTurn was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsBankedTurn changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsBankedTurn(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsBankedTurnValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsBankedTurn::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsBankedTurnValue_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsBankedTurnValue received: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsBankedTurnValue_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsBankedTurnValue exists in params ...");
      if (!this->get_parameter("PilotingSettingsBankedTurnValue", PilotingSettingsBankedTurnValue_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PilotingSettingsBankedTurnValue", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsBankedTurn

class PilotingSettingsMinAltitude : public AbstractSetting
{
private:
  double PilotingSettingsMinAltitudeCurrent_bebop_value_;
  bool PilotingSettingsMinAltitudeCurrent_bebop_sent_;
  double PilotingSettingsMinAltitudeCurrent_param_;

public:
  explicit PilotingSettingsMinAltitude()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED)
      , PilotingSettingsMinAltitudeCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMinAltitudeCurrent != PilotingSettingsMinAltitudeCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsMinAltitudeCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMinAltitudeCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsMinAltitude was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsMinAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMinAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMinAltitudeCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsMinAltitude::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMinAltitudeCurrent_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsMinAltitudeCurrent received: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMinAltitudeCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsMinAltitudeCurrent exists in params ...");
      if (!this->get_parameter("PilotingSettingsMinAltitudeCurrent", PilotingSettingsMinAltitudeCurrent_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<double>("PilotingSettingsMinAltitudeCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsMinAltitude

class PilotingSettingsCirclingDirection : public AbstractSetting
{
private:
  int32_t PilotingSettingsCirclingDirectionValue_bebop_value_;
  bool PilotingSettingsCirclingDirectionValue_bebop_sent_;
  int32_t PilotingSettingsCirclingDirectionValue_param_;

public:
  explicit PilotingSettingsCirclingDirection()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED)
      , PilotingSettingsCirclingDirectionValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsCirclingDirectionValue != PilotingSettingsCirclingDirectionValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsCirclingDirectionValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsCirclingDirectionValue_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsCirclingDirection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsCirclingDirection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsCirclingDirection(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE>(config.PilotingSettingsCirclingDirectionValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsCirclingDirection::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsCirclingDirectionValue_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsCirclingDirectionValue received: " << static_cast<int32_t>(arg->value.I32));
      PilotingSettingsCirclingDirectionValue_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsCirclingDirectionValue exists in params ...");
      if (!this->get_parameter("PilotingSettingsCirclingDirectionValue", PilotingSettingsCirclingDirectionValue_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PilotingSettingsCirclingDirectionValue", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsCirclingDirection

class PilotingSettingsCirclingRadius : public AbstractSetting
{
private:
  int32_t PilotingSettingsCirclingRadiusValue_bebop_value_;
  bool PilotingSettingsCirclingRadiusValue_bebop_sent_;
  int32_t PilotingSettingsCirclingRadiusValue_param_;

public:
  explicit PilotingSettingsCirclingRadius()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED)
      , PilotingSettingsCirclingRadiusValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsCirclingRadiusValue != PilotingSettingsCirclingRadiusValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsCirclingRadiusValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsCirclingRadiusValue_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsCirclingRadius was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsCirclingRadius changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsCirclingRadius(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsCirclingRadiusValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsCirclingRadius::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsCirclingRadiusValue_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsCirclingRadiusValue received: " << static_cast<int32_t>(arg->value.U16));
      PilotingSettingsCirclingRadiusValue_bebop_value_ = static_cast<int32_t>(arg->value.U16);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsCirclingRadiusValue exists in params ...");
      if (!this->get_parameter("PilotingSettingsCirclingRadiusValue", PilotingSettingsCirclingRadiusValue_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PilotingSettingsCirclingRadiusValue", static_cast<int32_t>(arg->value.U16));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsCirclingRadius

class PilotingSettingsCirclingAltitude : public AbstractSetting
{
private:
  int32_t PilotingSettingsCirclingAltitudeValue_bebop_value_;
  bool PilotingSettingsCirclingAltitudeValue_bebop_sent_;
  int32_t PilotingSettingsCirclingAltitudeValue_param_;

public:
  explicit PilotingSettingsCirclingAltitude()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED)
      , PilotingSettingsCirclingAltitudeValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsCirclingAltitudeValue != PilotingSettingsCirclingAltitudeValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsCirclingAltitudeValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsCirclingAltitudeValue_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsCirclingAltitude was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsCirclingAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsCirclingAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsCirclingAltitudeValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsCirclingAltitude::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsCirclingAltitudeValue_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsCirclingAltitudeValue received: " << static_cast<int32_t>(arg->value.U16));
      PilotingSettingsCirclingAltitudeValue_bebop_value_ = static_cast<int32_t>(arg->value.U16);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsCirclingAltitudeValue exists in params ...");
      if (!this->get_parameter("PilotingSettingsCirclingAltitudeValue", PilotingSettingsCirclingAltitudeValue_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PilotingSettingsCirclingAltitudeValue", static_cast<int32_t>(arg->value.U16));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsCirclingAltitude

class PilotingSettingsPitchMode : public AbstractSetting
{
private:
  int32_t PilotingSettingsPitchModeValue_bebop_value_;
  bool PilotingSettingsPitchModeValue_bebop_sent_;
  int32_t PilotingSettingsPitchModeValue_param_;

public:
  explicit PilotingSettingsPitchMode()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED)
      , PilotingSettingsPitchModeValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsPitchModeValue != PilotingSettingsPitchModeValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PilotingSettingsPitchModeValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsPitchModeValue_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PilotingSettingsPitchMode was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PilotingSettingsPitchMode changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsPitchMode(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE>(config.PilotingSettingsPitchModeValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PilotingSettingsPitchMode::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsPitchModeValue_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PilotingSettingsPitchModeValue received: " << static_cast<int32_t>(arg->value.I32));
      PilotingSettingsPitchModeValue_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PilotingSettingsPitchModeValue exists in params ...");
      if (!this->get_parameter("PilotingSettingsPitchModeValue", PilotingSettingsPitchModeValue_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PilotingSettingsPitchModeValue", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PilotingSettingsPitchMode

class SpeedSettingsMaxVerticalSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_;
  double SpeedSettingsMaxVerticalSpeedCurrent_param_;

public:
  explicit SpeedSettingsMaxVerticalSpeed()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED)
      , SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxVerticalSpeedCurrent != SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "SpeedSettingsMaxVerticalSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of SpeedSettingsMaxVerticalSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending SpeedSettingsMaxVerticalSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxVerticalSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxVerticalSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "SpeedSettingsMaxVerticalSpeed::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for SpeedSettingsMaxVerticalSpeedCurrent received: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if SpeedSettingsMaxVerticalSpeedCurrent exists in params ...");
      if (!this->get_parameter("SpeedSettingsMaxVerticalSpeedCurrent", SpeedSettingsMaxVerticalSpeedCurrent_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<double>("SpeedSettingsMaxVerticalSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // SpeedSettingsMaxVerticalSpeed

class SpeedSettingsMaxRotationSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxRotationSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_;
  double SpeedSettingsMaxRotationSpeedCurrent_param_;

public:
  explicit SpeedSettingsMaxRotationSpeed()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED)
      , SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxRotationSpeedCurrent != SpeedSettingsMaxRotationSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "SpeedSettingsMaxRotationSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of SpeedSettingsMaxRotationSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending SpeedSettingsMaxRotationSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxRotationSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxRotationSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "SpeedSettingsMaxRotationSpeed::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for SpeedSettingsMaxRotationSpeedCurrent received: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxRotationSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if SpeedSettingsMaxRotationSpeedCurrent exists in params ...");
      if (!this->get_parameter("SpeedSettingsMaxRotationSpeedCurrent", SpeedSettingsMaxRotationSpeedCurrent_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<double>("SpeedSettingsMaxRotationSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // SpeedSettingsMaxRotationSpeed

class SpeedSettingsHullProtection : public AbstractSetting
{
private:
  int32_t SpeedSettingsHullProtectionPresent_bebop_value_;
  bool SpeedSettingsHullProtectionPresent_bebop_sent_;
  int32_t SpeedSettingsHullProtectionPresent_param_;

public:
  explicit SpeedSettingsHullProtection()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED)
      , SpeedSettingsHullProtectionPresent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsHullProtectionPresent != SpeedSettingsHullProtectionPresent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "SpeedSettingsHullProtectionPresent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsHullProtectionPresent_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of SpeedSettingsHullProtection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending SpeedSettingsHullProtection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsHullProtection(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsHullProtectionPresent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "SpeedSettingsHullProtection::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT, arg);
    if (arg)
    {
      SpeedSettingsHullProtectionPresent_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for SpeedSettingsHullProtectionPresent received: " << static_cast<int32_t>(arg->value.U8));
      SpeedSettingsHullProtectionPresent_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if SpeedSettingsHullProtectionPresent exists in params ...");
      if (!this->get_parameter("SpeedSettingsHullProtectionPresent", SpeedSettingsHullProtectionPresent_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("SpeedSettingsHullProtectionPresent", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // SpeedSettingsHullProtection

class SpeedSettingsOutdoor : public AbstractSetting
{
private:
  int32_t SpeedSettingsOutdoorOutdoor_bebop_value_;
  bool SpeedSettingsOutdoorOutdoor_bebop_sent_;
  int32_t SpeedSettingsOutdoorOutdoor_param_;

public:
  explicit SpeedSettingsOutdoor()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED)
      , SpeedSettingsOutdoorOutdoor_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsOutdoorOutdoor != SpeedSettingsOutdoorOutdoor_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "SpeedSettingsOutdoorOutdoor changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsOutdoorOutdoor_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of SpeedSettingsOutdoor was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending SpeedSettingsOutdoor changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsOutdoor(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsOutdoorOutdoor)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "SpeedSettingsOutdoor::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR, arg);
    if (arg)
    {
      SpeedSettingsOutdoorOutdoor_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for SpeedSettingsOutdoorOutdoor received: " << static_cast<int32_t>(arg->value.U8));
      SpeedSettingsOutdoorOutdoor_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if SpeedSettingsOutdoorOutdoor exists in params ...");
      if (!this->get_parameter("SpeedSettingsOutdoorOutdoor", SpeedSettingsOutdoorOutdoor_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("SpeedSettingsOutdoorOutdoor", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // SpeedSettingsOutdoor

class SpeedSettingsMaxPitchRollRotationSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_;
  double SpeedSettingsMaxPitchRollRotationSpeedCurrent_param_;

public:
  explicit SpeedSettingsMaxPitchRollRotationSpeed()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED)
      , SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxPitchRollRotationSpeedCurrent != SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "SpeedSettingsMaxPitchRollRotationSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of SpeedSettingsMaxPitchRollRotationSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending SpeedSettingsMaxPitchRollRotationSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxPitchRollRotationSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxPitchRollRotationSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "SpeedSettingsMaxPitchRollRotationSpeed::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for SpeedSettingsMaxPitchRollRotationSpeedCurrent received: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if SpeedSettingsMaxPitchRollRotationSpeedCurrent exists in params ...");
      if (!this->get_parameter("SpeedSettingsMaxPitchRollRotationSpeedCurrent", SpeedSettingsMaxPitchRollRotationSpeedCurrent_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<double>("SpeedSettingsMaxPitchRollRotationSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // SpeedSettingsMaxPitchRollRotationSpeed

class NetworkSettingsWifiSelection : public AbstractSetting
{
private:
  int32_t NetworkSettingsWifiSelectionType_bebop_value_;
  bool NetworkSettingsWifiSelectionType_bebop_sent_;
  int32_t NetworkSettingsWifiSelectionType_param_;
  int32_t NetworkSettingsWifiSelectionBand_bebop_value_;
  bool NetworkSettingsWifiSelectionBand_bebop_sent_;
  int32_t NetworkSettingsWifiSelectionBand_param_;
  int32_t NetworkSettingsWifiSelectionChannel_bebop_value_;
  bool NetworkSettingsWifiSelectionChannel_bebop_sent_;
  int32_t NetworkSettingsWifiSelectionChannel_param_;

public:
  explicit NetworkSettingsWifiSelection()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED)
      , NetworkSettingsWifiSelectionType_bebop_sent_(false)
      , NetworkSettingsWifiSelectionBand_bebop_sent_(false)
      , NetworkSettingsWifiSelectionChannel_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionType != NetworkSettingsWifiSelectionType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "NetworkSettingsWifiSelectionType changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionType_bebop_sent_;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionBand != NetworkSettingsWifiSelectionBand_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "NetworkSettingsWifiSelectionBand changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionBand_bebop_sent_;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionChannel != NetworkSettingsWifiSelectionChannel_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "NetworkSettingsWifiSelectionChannel changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionChannel_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of NetworkSettingsWifiSelection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending NetworkSettingsWifiSelection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendNetworkSettingsWifiSelection(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE>(config.NetworkSettingsWifiSelectionType)
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND>(config.NetworkSettingsWifiSelectionBand)
        , (config.NetworkSettingsWifiSelectionChannel)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "NetworkSettingsWifiSelection::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionType_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for NetworkSettingsWifiSelectionType received: " << static_cast<int32_t>(arg->value.I32));
      NetworkSettingsWifiSelectionType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if NetworkSettingsWifiSelectionType exists in params ...");
      if (!this->get_parameter("NetworkSettingsWifiSelectionType", NetworkSettingsWifiSelectionType_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("NetworkSettingsWifiSelectionType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionBand_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for NetworkSettingsWifiSelectionBand received: " << static_cast<int32_t>(arg->value.I32));
      NetworkSettingsWifiSelectionBand_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if NetworkSettingsWifiSelectionBand exists in params ...");
      if (!this->get_parameter("NetworkSettingsWifiSelectionBand", NetworkSettingsWifiSelectionBand_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("NetworkSettingsWifiSelectionBand", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionChannel_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for NetworkSettingsWifiSelectionChannel received: " << static_cast<int32_t>(arg->value.U8));
      NetworkSettingsWifiSelectionChannel_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if NetworkSettingsWifiSelectionChannel exists in params ...");
      if (!this->get_parameter("NetworkSettingsWifiSelectionChannel", NetworkSettingsWifiSelectionChannel_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("NetworkSettingsWifiSelectionChannel", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // NetworkSettingsWifiSelection

class PictureSettingsVideoStabilizationMode : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoStabilizationModeMode_bebop_value_;
  bool PictureSettingsVideoStabilizationModeMode_bebop_sent_;
  int32_t PictureSettingsVideoStabilizationModeMode_param_;

public:
  explicit PictureSettingsVideoStabilizationMode()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED)
      , PictureSettingsVideoStabilizationModeMode_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoStabilizationModeMode != PictureSettingsVideoStabilizationModeMode_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PictureSettingsVideoStabilizationModeMode changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoStabilizationModeMode_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PictureSettingsVideoStabilizationMode was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PictureSettingsVideoStabilizationMode changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoStabilizationMode(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE>(config.PictureSettingsVideoStabilizationModeMode)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PictureSettingsVideoStabilizationMode::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE, arg);
    if (arg)
    {
      PictureSettingsVideoStabilizationModeMode_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PictureSettingsVideoStabilizationModeMode received: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoStabilizationModeMode_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PictureSettingsVideoStabilizationModeMode exists in params ...");
      if (!this->get_parameter("PictureSettingsVideoStabilizationModeMode", PictureSettingsVideoStabilizationModeMode_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PictureSettingsVideoStabilizationModeMode", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PictureSettingsVideoStabilizationMode

class PictureSettingsVideoRecordingMode : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoRecordingModeMode_bebop_value_;
  bool PictureSettingsVideoRecordingModeMode_bebop_sent_;
  int32_t PictureSettingsVideoRecordingModeMode_param_;

public:
  explicit PictureSettingsVideoRecordingMode()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED)
      , PictureSettingsVideoRecordingModeMode_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoRecordingModeMode != PictureSettingsVideoRecordingModeMode_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PictureSettingsVideoRecordingModeMode changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoRecordingModeMode_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PictureSettingsVideoRecordingMode was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PictureSettingsVideoRecordingMode changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoRecordingMode(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE>(config.PictureSettingsVideoRecordingModeMode)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PictureSettingsVideoRecordingMode::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE, arg);
    if (arg)
    {
      PictureSettingsVideoRecordingModeMode_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PictureSettingsVideoRecordingModeMode received: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoRecordingModeMode_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PictureSettingsVideoRecordingModeMode exists in params ...");
      if (!this->get_parameter("PictureSettingsVideoRecordingModeMode", PictureSettingsVideoRecordingModeMode_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PictureSettingsVideoRecordingModeMode", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PictureSettingsVideoRecordingMode

class PictureSettingsVideoFramerate : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoFramerateFramerate_bebop_value_;
  bool PictureSettingsVideoFramerateFramerate_bebop_sent_;
  int32_t PictureSettingsVideoFramerateFramerate_param_;

public:
  explicit PictureSettingsVideoFramerate()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED)
      , PictureSettingsVideoFramerateFramerate_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoFramerateFramerate != PictureSettingsVideoFramerateFramerate_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PictureSettingsVideoFramerateFramerate changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoFramerateFramerate_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PictureSettingsVideoFramerate was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PictureSettingsVideoFramerate changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoFramerate(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE>(config.PictureSettingsVideoFramerateFramerate)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PictureSettingsVideoFramerate::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE, arg);
    if (arg)
    {
      PictureSettingsVideoFramerateFramerate_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PictureSettingsVideoFramerateFramerate received: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoFramerateFramerate_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PictureSettingsVideoFramerateFramerate exists in params ...");
      if (!this->get_parameter("PictureSettingsVideoFramerateFramerate", PictureSettingsVideoFramerateFramerate_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PictureSettingsVideoFramerateFramerate", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PictureSettingsVideoFramerate

class PictureSettingsVideoResolutions : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoResolutionsType_bebop_value_;
  bool PictureSettingsVideoResolutionsType_bebop_sent_;
  int32_t PictureSettingsVideoResolutionsType_param_;

public:
  explicit PictureSettingsVideoResolutions()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED)
      , PictureSettingsVideoResolutionsType_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoResolutionsType != PictureSettingsVideoResolutionsType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "PictureSettingsVideoResolutionsType changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoResolutionsType_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of PictureSettingsVideoResolutions was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending PictureSettingsVideoResolutions changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoResolutions(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE>(config.PictureSettingsVideoResolutionsType)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "PictureSettingsVideoResolutions::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE, arg);
    if (arg)
    {
      PictureSettingsVideoResolutionsType_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for PictureSettingsVideoResolutionsType received: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoResolutionsType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if PictureSettingsVideoResolutionsType exists in params ...");
      if (!this->get_parameter("PictureSettingsVideoResolutionsType", PictureSettingsVideoResolutionsType_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("PictureSettingsVideoResolutionsType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // PictureSettingsVideoResolutions

class GPSSettingsHomeType : public AbstractSetting
{
private:
  int32_t GPSSettingsHomeTypeType_bebop_value_;
  bool GPSSettingsHomeTypeType_bebop_sent_;
  int32_t GPSSettingsHomeTypeType_param_;

public:
  explicit GPSSettingsHomeType()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED)
      , GPSSettingsHomeTypeType_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.GPSSettingsHomeTypeType != GPSSettingsHomeTypeType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "GPSSettingsHomeTypeType changed!");
      changed = true;
    }
    all_inited &= GPSSettingsHomeTypeType_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of GPSSettingsHomeType was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending GPSSettingsHomeType changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsHomeType(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE>(config.GPSSettingsHomeTypeType)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "GPSSettingsHomeType::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE, arg);
    if (arg)
    {
      GPSSettingsHomeTypeType_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for GPSSettingsHomeTypeType received: " << static_cast<int32_t>(arg->value.I32));
      GPSSettingsHomeTypeType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if GPSSettingsHomeTypeType exists in params ...");
      if (!this->get_parameter("GPSSettingsHomeTypeType", GPSSettingsHomeTypeType_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("GPSSettingsHomeTypeType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // GPSSettingsHomeType

class GPSSettingsReturnHomeDelay : public AbstractSetting
{
private:
  int32_t GPSSettingsReturnHomeDelayDelay_bebop_value_;
  bool GPSSettingsReturnHomeDelayDelay_bebop_sent_;
  int32_t GPSSettingsReturnHomeDelayDelay_param_;

public:
  explicit GPSSettingsReturnHomeDelay()
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED)
      , GPSSettingsReturnHomeDelayDelay_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.GPSSettingsReturnHomeDelayDelay != GPSSettingsReturnHomeDelayDelay_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO,"CB",
        "GPSSettingsReturnHomeDelayDelay changed!");
      changed = true;
    }
    all_inited &= GPSSettingsReturnHomeDelayDelay_bebop_sent_;

    if (changed && !all_inited)
    {
      RCLCPP_ERROR(rclcpp::get_logger("CB"),
        "Value of GPSSettingsReturnHomeDelay was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      RCLCPP_INFO(rclcpp::get_logger("CB"),
        "Sending GPSSettingsReturnHomeDelay changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsReturnHomeDelay(bebop_ctrl_ptr_->aRDrone3
        , (config.GPSSettingsReturnHomeDelayDelay)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const rclcpp::Time& t)
  {
    if (arguments == NULL)
    {
      RCLCPP_WARN(rclcpp::get_logger("CB"),
        "GPSSettingsReturnHomeDelay::Update() arguments is NULL");
      return;
    }

    boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR(arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY, arg);
    if (arg)
    {
      GPSSettingsReturnHomeDelayDelay_bebop_sent_ = true;
      RCLCPP_INFO_STREAM(rclcpp::get_logger("CB"), "Value for GPSSettingsReturnHomeDelayDelay received: " << static_cast<int32_t>(arg->value.U16));
      GPSSettingsReturnHomeDelayDelay_bebop_value_ = static_cast<int32_t>(arg->value.U16);

      RCLCPP_INFO(rclcpp::get_logger("CB"), "Checking if GPSSettingsReturnHomeDelayDelay exists in params ...");
      if (!this->get_parameter("GPSSettingsReturnHomeDelayDelay", GPSSettingsReturnHomeDelayDelay_param_))
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "CB: No");
        this->declare_parameter<int32_t>("GPSSettingsReturnHomeDelayDelay", static_cast<int32_t>(arg->value.U16));
      }
      else
      {
        RCLCPP_INFO(rclcpp::get_logger("CB"), "  Yes");
      }
    }
  }
};  // GPSSettingsReturnHomeDelay

}  // namespace cb
}  // namespace bebop_driver
#endif  // BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H
